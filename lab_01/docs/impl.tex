\chapter{Технологическая часть}

В данном разделе приведены требования к программному обеспечению, средства реализации и листинги кода.

\section{Средства реализации}

В качестве языка программирования для реализации данной лабораторной работы был выбран язык Golang \cite{golang}, среда разработки Goland \cite{goland}. 

GoLang — это многопоточный компилируемый язык. По производительности Go почти не уступает C++ и в десятки раз превосходит скриптовые языки — такие, как JavaScript, Python, Ruby, PHP. При этом он имеет очень простой и понятный синтаксис. 

    1) Строгая статическая типизация. У каждой переменной — свой неизменяемый тип. Если вы изначально определили ее как целое число, значит, в течение всей программы она может быть только целым числом и ничем иным. Это свойство работает на простоту кода, делает его легко читаемым, а, кроме того, сводит к минимуму риск ошибок из-за невнимательности.
    
    2) Низкая требовательность к памяти. В GoLang есть «сборщик мусора» — периодически те объекты, потребность в которых уже не возникнет, удаляются. Таким образом происходит автоматическая очистка памяти.
    
    3) Большая библиотека. В ней есть все, что необходимо для разработки. Можно также использовать библиотеки других языков — C и C++.
    
    4) Простота параллельных вычислений. Язык идеально подходит для создания программ, рассчитанных на многоядерные процессоры. Многопоточность, реализуемая через так называемые горутины (go routines), которые взаимодействуют посредством каналов, позволяет вызывать несколько функций практически одновременно. Эта возможность очень актуальна при создании больших и сложных программ. Средства параллельного программирования экономят время разработчика и помогают равномерно распределять ресурсы процессора.
    
Для замера процессорного времени выполнения программы используется функция GetProcessTimes() т.к. используется ОС Windows. \cite{GetProcessTimes}.

Подключение функций, написанныйх на языке C, в Golang производится с помощью "C" pseudo package \cite{cgo}.

\section{Реализация алгоритма нахождения расстояния Левенштейна - рекурсивно}

\begin{lstlisting}[language=Go, caption=Реализация алгоритма Левенштейна рекурсивным способом, label=lst_rec]	
func LevenshteinRecursive(s1, s2 string) int {
	s1Rune, s2Rune := []rune(s1), []rune(s2)

	s1_len, s2_len := len(s1Rune), len(s2Rune)

	return distance(s1Rune, s2Rune, s1_len, s2_len)

}
\end{lstlisting}

\begin{lstlisting}[language=Go, caption=Вспомогательная функция distance, label=dist]	
func distance(s1, s2 []rune, i, j int) int {
	if i == 0 {
		return j
	}
	if j == 0 {
		return i
	}
	cost := 1
	if s1[i - 1] == s2[j - 1] {
		cost = 0
	}
	return findMin(distance(s1, s2, i, j - 1) + 1,
		distance(s1, s2, i - 1, j) + 1,
		distance(s1, s2, i - 1, j - 1) + cost)
}
\end{lstlisting}

\section{Реализация алгоритма нахождения расстояния Левенштейна - матрично}

\begin{lstlisting}[language=Go, caption=Реализация алгоритма Левенштейна матричным способом, label=lst_mat]
func LevenshteinMatrix(s1, s2 string) (int, intMatrix) {
	var (
		len_s1, len_s2, dist, shDist int
	)

	s1Rune, s2Rune := []rune(s1), []rune(s2)

	len_s1, len_s2 = len(s1Rune), len(s2Rune)

	distMat := make(intMatrix, len_s1+1)

	for i := range distMat {
		distMat[i] = make([]int, len_s2+1)
	}

	for i := 0; i < len_s2+1; i++ {
		distMat[0][i] = i
	}

	for i := 0; i < len_s1+1; i++ {
		distMat[i][0] = i
	}

	for i := 1; i < len_s1+1; i++ {
		for j := 1; j < len_s2+1; j++ {
			cost := 1
			if s1Rune[i-1] == s2Rune[j-1] {
				cost = 0
			}
			dist = findMin(	distMat[i][j-1] + 1,
							distMat[i-1][j] + 1,
							distMat[i-1][j-1] + cost)
			distMat[i][j] = dist
		}
	}

	shDist = distMat[len_s1][len_s2]

	return shDist, distMat
}
\end{lstlisting}


\section{Реализация алгоритма нахождения расстояния Левенштейна - рекурсивно с использованием кэша}

\begin{lstlisting}[language=Go, caption=Реализация алгоритма Левенштейна рекурсивным способом с использованием кэширования, label=lst_rec_cache]
func LevenshteinRecursiveCache(s1, s2 string) (int) {
	var (
		len_s1, len_s2 int
	)
	s1Rune, s2Rune := []rune(s1), []rune(s2)
	len_s1, len_s2 = len(s1Rune), len(s2Rune)
	cache := make(map[pair]int)
	SubLevenshteinRecursiveCache(s1Rune, s2Rune, len_s1, len_s2, cache)
	resPair := pair{len_s1, len_s2}
	return cache[resPair]
}
\end{lstlisting}

\begin{lstlisting}[language=Go, caption=Вспомогательная функция SubLevenshteinRecursiveCache, label=distrec]	
func SubLevenshteinRecursiveCache(s1, s2 []rune, i, j int, cache map[pair]int) int {
	strs := pair{i, j}
	if _, ok := cache[strs]; ok {
		return cache[strs]
	}
	if i == 0 && j == 0 {
		cache[strs] = 0
	} else if j == 0{
		cache[strs] = i
	} else if i == 0 {
		cache[strs] = j
	} else {
		cost := 1
		if s1[i-1] == s2[j-1] {
			cost = 0
		}
		cache[strs] = findMin(
			SubLevenshteinRecursiveCache(s1, s2, i, j-1, cache)+1,
			SubLevenshteinRecursiveCache(s1, s2, i-1, j, cache)+1,
			SubLevenshteinRecursiveCache(s1, s2, i-1, j-1, cache)+cost)
	}
	return cache[strs]
}
\end{lstlisting}

\section{Реализация алгоритма нахождения расстояния Дамерау-Левенштейна - рекурсивно}
\begin{lstlisting}[language=Go, caption=Реализация алгоритма Дамерау-Левенштейна рекурсивным способом, label=lst_dam]
func DamerauLevenshtein(s1, s2 string) (int) {
	var (
		len_s1, len_s2 int
	)
	s1Rune, s2Rune := []rune(s1), []rune(s2)
	len_s1, len_s2 = len(s1Rune), len(s2Rune)
	result := SubDamerauLevenshtein(s1Rune, s2Rune, len_s1, len_s2)
	return result
}
\end{lstlisting}

\begin{lstlisting}[language=Go, caption=Вспомогательная функция, label=dl]	
func SubDamerauLevenshtein(s1, s2 []rune, i, j int) int {
	var result int
	if i == 0 && j == 0 {
		return 0
	} else if j == 0{
		return i
	} else if i == 0 {
		return j
	} else {
		cost := 1
		if s1[i-1] == s2[j-1] {
			cost = 0
		}
		result = findMin(
			SubDamerauLevenshtein(s1, s2, i, j-1)+1,
			SubDamerauLevenshtein(s1, s2, i-1, j)+1,
			SubDamerauLevenshtein(s1, s2, i-1, j-1)+cost)
		if i > 1 && j > 1 && s1[i-2] == s2[j-1] && s1[i-1] == s2[j-2] {
			result = findMin(SubDamerauLevenshtein(s1, s2, i-2, j-2)+1, result)
		}
	}
	return result
}
\end{lstlisting}

\section{Тестирование}
На листинге \ref{cputime} представлена реализация функции получения процессорного времени \cite{getCPUTime} в миллисекундах.
\begin{lstlisting}[language=Go, caption=Измерение процессорного времени, label=cputime]
/*
   #include <Windows.h>
   #include <stdio.h>

   double getCPUTime(void) {
    FILETIME createTime;
    FILETIME exitTime;
    FILETIME kernelTime;
    FILETIME userTime;
    if ( GetProcessTimes( GetCurrentProcess( ),
        &createTime, &exitTime, &kernelTime, &userTime ) != -1 )
    {
        SYSTEMTIME userSystemTime;
        if ( FileTimeToSystemTime( &userTime, &userSystemTime ) != -1 )
            return (double)userSystemTime.wHour * 3600000.0 +
                (double)userSystemTime.wMinute * 60000.0 +
                (double)userSystemTime.wSecond * 1000 +
                (double)userSystemTime.wMilliseconds;
    }
    return -1;
}
*/
import "C"

func GetCPU() float64 {
	result := (float64)(C.getCPUTime())
	return result
}
\end{lstlisting}


\section*{Вывод}

Были разработаны и протестированы спроектированные алгоритмы: вычисления расстояния Левенштейна рекурсивно, с заполнением матрицы и рекурсивно с заполнением матрицы, а также вычисления расстояния Дамерау — Левенштейна с заполнением матрицы.
