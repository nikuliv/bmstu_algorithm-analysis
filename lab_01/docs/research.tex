\chapter{Исследовательская часть}

\section{Пример работы}

Демонстрация работы программы приведена на рисунке \ref{img:work}.

\boximg{50mm}{work}{Демонстрация работы алгоритмов нахождения расстояния Левенштейна и Дамерау -- Левенштейна}

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item Операционная система: Windows 10 Pro \cite{windows} 64-bit.
	\item ОЗУ: 16 GB.
	\item Процессор: Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz \cite{Intel}
\end{itemize}

Тестирование проводилось на компьютере, включенном в сеть электропитания. Во время тестирования компьютер был нагружен только встроенными приложениями окружения рабочего стола, окружением рабочего стола, а также непосредственно системой тестирования.

\section{Время выполнения алгоритмов}

Алгоритмы тестировались при помощи функции GetProcessTimes \cite{GetProcessTimes}, предоставяющей возможность измерить процессорное время на программе на языке C/C++, запущенной на операционной системе Windows. Для получения более точных результатов тестирования, функции выполнялись большое количество раз. Рекурсивная реализация алгоритма вычисления расстояния Левенштейна не тестировалась при длине слов больше 10, из-за слишком большого времени работы.

Результаты замеров (в мс) приведены на рисунке \ref{img:time}.
На рисунках \ref{plt:time_levenshtein_rec}, \ref{plt:time_levenshtein} приведены зависимости времени работы алгоритмов от длины строк.

\boximg{80mm}{time}{Замер времени для строк, размером от 5 до 100}

\begin{figure}
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			axis lines=left,
			xlabel=Длина строк,
			ylabel={Время, нс},
			legend pos=north east,
			ymajorgrids=true
			]
			\addplot 
					coordinates {(5,0.01422) (6,0.02156) (7,0.03125)(8,0.03406) (9,0.0411) (10,0.05765) (20,0.22953) (30,0.51453) (40,0.87359) (50,1.28453) (60,2.05718) (70,2.57438) (80,3.2225) (90,4.66781) (100,5.52484)};
			\addplot 
					coordinates {(5,0.00094) (6,0.00188) (7,0.00172)(8,0.00188) (9,0.00219) (10,0.0025) (20,0.00813) (30,0.01625) (40,0.03094) (50,0.04328) (60,0.0611) (70,0.08391) (80,0.1164) (90,0.14813) (100,0.17891)};
			\legend{Рекурсивный (cache), Матричный}
		\end{axis}
	\end{tikzpicture}
	\captionsetup{justification=centering}
	\caption{Зависимость времени работы (в мс) алгоритма вычисления расстояния Левенштейна от длины строк (Рекурсивный с кешированием, Матричный)}
	\label{plt:time_levenshtein_rec}
\end{figure}

\begin{figure}
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			axis lines=left,
			xlabel=Длина строк,
			ylabel={Время, нс},
			legend pos=north west,
			ymajorgrids=true
			]
			\addplot 
					coordinates {(5,0.015) (6,0.094) (7,0.5) (8,2.793) (9,14.109)};
			\addplot 
					coordinates {(5,0.01422) (6,0.02156) (7,0.03125)(8,0.03406) (9,0.0411)};
			\legend{Рекурсивный, Рекурсивный (cache)}
		\end{axis}
	\end{tikzpicture}
	\captionsetup{justification=centering}
	\caption{Зависимость времени работы (в мс) алгоритма вычисления расстояния Левенштейна от длины строк (Рекурсивный, Рекурсивный с кэшированием)}
	\label{plt:time_levenshtein}
\end{figure}

% \begin{figure}
% 	\centering
% 	\begin{tikzpicture}
% 		\begin{axis}[
% 			axis lines=left,
% 			xlabel=Длина строк,
% 			ylabel={Время, нс},
% 			legend pos=north west,
% 			ymajorgrids=true
% 			]
% 			\addplot 
% 					coordinates {(5,0.015) (6,0.094) (7,0.5) (8,2.793) (9,14.109)};
% 			\addplot 
% 					coordinates {(5,0.015) (6,0.109) (7,0.578)(8,3.047) (9,14.675)};
% 			\legend{Рекурсивный, Дамерау-Левенштейн}
% 		\end{axis}
% 	\end{tikzpicture}
% 	\captionsetup{justification=centering}
% 	\caption{Зависимость времени работы (в мс) алгоритма вычисления расстояния Левенштейна от длины строк (Рекурсивный, Дамерау-Левенштейн)}
% 	\label{plt:time_levenshtein}
% \end{figure}

\section{Использование памяти}

\newpageАлгоритмы вычисления расстояний Левенштейна и Дамерау — Левенштейна не отличаются друг от друга с точки зрения использования памяти, следовательно, достаточно рассмотреть лишь разницу рекурсивной и матричной реализаций этих алгоритмов.

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк, соответственно, максимальный расход памяти вычисляется по формуле (\ref{for:99})
\begin{equation}
(\mathcal{C}(S_1) + \mathcal{C}(S_2)) \cdot (2 \cdot \mathcal{C}\mathrm{(string)} + 3 \cdot \mathcal{C}\mathrm{(size\_t)}),
\label{for:99}
\end{equation}
где $\mathcal{C}$ — оператор вычисления размера, $S_1$, $S_2$ — строки, $\mathrm{int}$ — целочисленный тип, $\mathrm{string}$ — строковый тип.

Использование памяти при матричной реализации теоретически вычисляется по формуле (\ref{for:100}).
\begin{equation}
(\mathcal{C}(S_1) + 1) \cdot (\mathcal{C}(S_2) + 1) \cdot \mathcal{C}\mathrm{(int)} + 10\cdot \mathcal{C}\mathrm{(int)} + 2 \cdot \mathcal{C}\mathrm{(string)})
\label{for:100}
\end{equation}

Использование памяти при рекурсивной реализации с заполнением матрицы теоретически равно сумме использумой памяти в рекурсивном и итеративном алгоритмах.

\boximg{80mm}{memory}{Замеры выполненные с использованием бенчмарков}


\section*{Вывод}

На словах длиной 9 символов, матричная реализация алгоритма вычисления расстояния Левенштейна превосходит по времени работы рекурсивную в около 6500 раз. Рекурсивный алгоритм с заполнением матрицы превосходит простой рекурсивный на аналогичных данных в около 350 раз. Алгоритм вычисления расстояния Дамерау — Левенштейна используется для решения других задач, поэтому говорить о его отставании от алгоритма вычисления расстояния Левенштейна, исходя из временных затрат, некорректно.

По расходу памяти алгоритмы с использованием матрицы проигрывают рекурсивному: максимальный размер используемой памяти в них растёт как произведение длин строк, в то время как у рекурсивного алгоритма — как сумма длин строк.
